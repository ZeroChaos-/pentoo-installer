#!/bin/bash
# This script is released under the GNU General Public License 3.0
# Check the COPYING file included with this distribution

# install_bootloader_grub
# installs traditional Grub
#
# parameters (required)
#  CONFIG_LIST: One string items of defined FSspec
#
# returns 0 on success
# returns $ERROR_CANCEL=64 on user cancel
# anything else is a real error
# reason: show_dialog() needs a way to exit "Cancel"
#
# writes menus and noise to STDERR

# location of other scripts to source
readonly SHAREDIR="$(dirname ${0})" || exit $?

# source partitioning commons
source "${SHAREDIR}"/partition_common.sh || exit $?

#########################################
## START: dialog functions/definitions ##

# get_grub_map()
# prints grub device map to /tmp/.dev.map
#
# parameters (none)
#
get_grub_map() {
	# check input
	check_num_args "${FUNCNAME}" 0 $# || return $?
    [ -e /tmp/.dev.map ] && rm /tmp/.dev.map
    show_dialog --infobox "Generating GRUB device map...\nThis could take a while.\n\n Please be patient." 0 0
    ${DESTDIR}/sbin/grub --no-floppy --device-map /tmp/.dev.map >/tmp/grub.log 2>&1 <<EOF
quit
EOF
}

# getkernelversion()
# outputs the kernel version
#
# parameters: none
# outputs:    kernel version on success
#             nothing on failure
# returns:    0 on success
#             1 on failure
getkernelversion() {
    local _KERNVER=$(ls "${DESTDIR}"/boot/kernel-genkernel-* | sed -e "s|kernel-genkernel||g" -e "s|${DESTDIR}/boot/||") \
        || return 1
    echo "${_KERNVER}"
}

# mapdev()
# maps a device to a grub device
# uses /tmp/.dev.map from get_grub_map()
#
# parameters (required)
#  _SEARCHDEV: The partition
#
# TODO: rewrite this, or someone explain it ;)
#
mapdev() {
	# check input
	check_num_args "${FUNCNAME}" 1 $# || return $?
	local _SEARCHDEV="$1"
    local _PARTITION_FLAG=0
    local _DEVICE_FOUND=0
	local _ALLDEVS=
	local _TMPDEV=
	local _LINUXDEVICE=
	local _PNUM=
	local _GRUBDEVICE=
	local _GRUBDEVICE_STRINGLEN=
    _ALLDEVS="$(cat /tmp/dev.map | grep -v fd | sed 's/ *\t/ /' | sed ':a;$!N;$!ba;s/\n/ /g')" || return $?
    _LINUXDEVICE=$(echo "${_SEARCHDEV}" | cut -b1-8) || return $?
    if [ "$(echo "${_SEARCHDEV}" | egrep '[0-9]$')" ]; then
        # /dev/hdXY
        _PNUM=$(echo "${_SEARCHDEV}" | cut -b9-) || return $?
        _PNUM=$((${_PNUM}-1)) || return $?
        _PARTITION_FLAG=1
    fi
    for  _TMPDEV in ${_ALLDEVS}; do
		if [ "(" = $(echo ${_TMPDEV} | cut -b1) ]; then
			_GRUBDEVICE="${_TMPDEV}"
        elif [ "${_TMPDEV}" = "${_LINUXDEVICE}" ]; then
			_DEVICE_FOUND=1
			break
       fi
    done
    if [ "${_DEVICE_FOUND}" = "1" ]; then
        if [ "${_PARTITION_FLAG}" = "0" ]; then
            echo "${_GRUBDEVICE}"
        else
            _GRUBDEVICE_STRINGLEN=${#_GRUBDEVICE}
            _GRUBDEVICE_STRINGLEN=$((${_GRUBDEVICE_STRINGLEN} - 1)) || return $?
            _GRUBDEVICE=$(echo ${_GRUBDEVICE} | cut -b1-${_GRUBDEVICE_STRINGLEN}) || return $?
            echo "${_GRUBDEVICE},${_PNUM})"
        fi
    else
        echo "DEVICE '${_SEARCHDEV}' NOT FOUND" 1>&2
		return 1
    fi
	return 0
}

# parse_kernel_cmdline()
# parse kernel cmdline (only video mode for now)
# prints a string to STDOUT like 'video=whatever'
parse_kernel_cmdline() {
	local _VAR=
	local _FIRST=0
	for _VAR in $(cat /proc/cmdline); do
		case "${_VAR}" in
			video=*)
				[ "${_FIRST}" -ne 0 ] && echo -n ' '
				echo -n "${_VAR}"
				_FIRST=1
			;;
		esac
	done
}

## END: dialog functions/definitions ##
#######################################

#####################
## begin execution ##

# check input
check_num_args "$(basename $0)" 1 $# || exit $?
CONFIG_LIST="${1}"
CONFIG_ITEM=
RET_SUB=

# write grub device map to /tmp/... file
get_grub_map

GRUBMENU="${DESTDIR}/boot/grub/grub.conf"
rm ${DESTDIR}/boot/grub/menu.lst
# TODO: I dont like this ln
ln -s ./grub.conf ${DESTDIR}/boot/grub/menu.lst
# sanity check
if [ ! -f ${GRUBMENU} ]; then
	show_dialog --msgbox "Error: Couldn't find ${GRUBMENU}  Is GRUB installed?" 0 0
	exit 1
fi

# get root partition
CONFIG_ITEM="$("${SHAREDIR}"/FSspec listfind "${CONFIG_LIST}" 'mountpoint' '/')" || exit $?
PART_ROOT="$("${SHAREDIR}"/FSspec parse "${CONFIG_ITEM}" 'partition')" || exit $?
GRUBDEV=$(mapdev ${PART_ROOT})
GRUBDEV_FOUND=$?
ROOTPART="${PART_ROOT}"
# look for a separately-mounted /boot partition
BOOTDEV=
BOOTDEV=$(mount | grep ${DESTDIR}/boot | cut -d' ' -f 1)
SUBDIR=
KERNEL_PARAMS=

# parse kernel cmdline (only video mode for now)
KERNEL_PARAMS="$(parse_kernel_cmdline)" || exit $?
# get kernel version
KERNVER=$(getkernelversion) || exit $?

if [ "${GRUBDEV}" != "" -o "${BOOTDEV}" != "" ]; then
	if [ "${BOOTDEV}" != "" ]; then
		GRUBDEV=$(mapdev ${BOOTDEV})
		GRUBDEV_FOUND=$?
	else
		SUBDIR="/boot"
	fi
	# keep the file from being completely bogus
	if [ "${GRUBDEV_FOUND}" -ne 0 ]; then
		show_dialog --msgbox "Your root boot device could not be autodetected by setup.  Ensure you adjust the 'root (hd0,0)' line in your GRUB config accordingly." 0 0
		GRUBDEV="(hd0,0)"
	fi
	# remove default entries
	sed -i 's/^#splashimage/splashimage/' ${GRUBMENU} || exit $?
	sed -i '/^#/d' ${GRUBMENU} || exit $?

	if [ ${S_FDE} = 1 ]; then
		cat >>${GRUBMENU} <<EOF

# (0) Pentoo
title  Pentoo
root   ${GRUBDEV}
kernel ${SUBDIR}/kernel-genkernel${KERNVER} root=/dev/ram0 real_root=/dev/mapper/root dogpg crypt_root=${ROOTPART} root_key=/key.gpg root_keydev=${BOOTDEV} ${KERNEL_PARAMS} console=tty1 net.ifnames=0 ro
initrd ${SUBDIR}/initramfs-genkernel${KERNVER}

# (2) Windows
#title Windows
#rootnoverify (hd0,0)
#makeactive
#chainloader +1
EOF
		RET_SUB=$?
		[ "${RET_SUB}" -ne 0 ] && exit "${RET_SUB}"
	else
		cat >>${GRUBMENU} <<EOF

# (0) Pentoo
title  Pentoo
root   ${GRUBDEV}
kernel ${SUBDIR}/kernel-genkernel${KERNVER} root=/dev/ram0 real_root=${ROOTPART} ${KERNEL_PARAMS} console=tty1 net.ifnames=0 ro
initrd ${SUBDIR}/initramfs-genkernel${KERNVER}

# (2) Windows
#title Windows
#rootnoverify (hd0,0)
#makeactive
#chainloader +1
EOF
		RET_SUB=$?
		[ "${RET_SUB}" -ne 0 ] && exit "${RET_SUB}"
	fi
fi

show_dialog --msgbox "Before installing GRUB, you must review the configuration file.  You will now be put into the editor.  After you save your changes and exit the editor, you can install GRUB." 0 0

chroot_mount || exit $?
# set system editor (if not already defined)
EDITOR="$(geteditor)" || exit $?
chroot_umount || exit $?

DEVS="$(partition_finddisks)" || exit $?
DEVS="${DEVS} $(findpartitions)" || exit $?
DEVS=$(add_option_label "${DEVS}" '-') || exit $?
if [ "${DEVS}" = "" ]; then
	show_dialog --msgbox "No hard drives were found" 0 0
	exit 1
fi

ROOTDEV="$(show_dialog --menu "Select the boot device where the GRUB bootloader will be installed (usually the MBR and not a partition)." 0 0 0 ${DEVS})" || exit $?
show_dialog --infobox "Installing the GRUB bootloader..." 0 0
if [ -d "${DESTDIR}"/usr/lib/grub/i386-pc ]; then
	cp -a "${DESTDIR}"/usr/lib/grub/i386-pc/* "${DESTDIR}"/boot/grub/ || exit $?
fi
sync

# freeze xfs filesystems to enable grub installation on xfs filesystems
if [ -x /usr/sbin/xfs_freeze ]; then
	# TODO: test this
	mount | grep ${DESTDIR}/boot | grep -q xfs && /usr/sbin/xfs_freeze -f ${DESTDIR}/boot > /dev/null 2>&1 || exit $?
	mount | grep ${DESTDIR} | grep -q xfs && /usr/sbin/xfs_freeze -f ${DESTDIR}/ > /dev/null 2>&1 || exit $?
fi

# look for a separately-mounted /boot partition
BOOTPART=$(mount | grep ${DESTDIR}/boot | cut -d' ' -f 1)
if [ "${BOOTPART}" = "" ]; then
	if [ "${PART_ROOT}" = "" ]; then
		BOOTPART="$(show_dialog --inputbox "Enter the full path to your root device" 8 65 "/dev/sda3")" || exit $?
	else
		BOOTPART=${PART_ROOT}
	fi
fi
show_dialog --defaultno --yesno "Do you have your system installed on software raid?\nAnswer 'YES' to install grub to another hard disk." 0 0
if [ $? -eq 0 ]; then
	# TODO: redo-ing grub-installation .... vs. writing menu once like the above ... = conflict?
	BOOTPART="$(show_dialog --menu "Please select the boot partition device, this cannot be autodetected!\nPlease redo grub installation for all partitions you need it!" 14 55 7 ${DEVS})" || exit $?
fi
BOOTPART=$(mapdev ${BOOTPART})
BOOTPART_FOUND=$?
BOOTDEV=$(mapdev ${ROOTDEV})
BOOTDEV_FOUND=$?

if [ "${BOOTPART}" = "" ]; then
	show_dialog --msgbox "Error: Missing/Invalid root device: ${BOOTPART}" 0 0
	exit 1
fi

if [ "${BOOTPART_FOUND}" -ne 0 -o "${BOOTDEV_FOUND}" -ne 0 ]; then
	show_dialog --msgbox "GRUB root and setup devices could not be auto-located.  You will need to manually run the GRUB shell to install a bootloader." 0 0
	exit 1
fi

/sbin/grub-install --no-floppy --recheck --grub-shell=${DESTDIR}/sbin/grub --root-directory=${DESTDIR} ${ROOTDEV} >/tmp/grub.log 2>&1
cat /tmp/grub.log >"${LOG}"

# unfreeze xfs filesystems
if [ -x /usr/sbin/xfs_freeze ]; then
	mount | grep ${DESTDIR}/boot | grep -q xfs && /usr/sbin/xfs_freeze -u ${DESTDIR}/boot > /dev/null 2>&1 || exit $?
	mount | grep ${DESTDIR}/boot | grep -q xfs && /usr/sbin/xfs_freeze -u ${DESTDIR}/ > /dev/null 2>&1 || exit $?
fi

if grep "Error [0-9]*: " /tmp/grub.log >/dev/null; then
	show_dialog --msgbox "Error installing GRUB. (see ${LOG} for output)" 0 0
	exit 1
fi

show_dialog --msgbox "GRUB was successfully installed." 0 0
exit 0
