#!/bin/bash
# This script is released under the GNU General Public License 3.0
# Check the COPYING file included with this distribution

DESTDIR="/mnt/gentoo"
EDITOR=

# clock
HARDWARECLOCK=
TIMEZONE=

# install stages
S_CLOCK=0       # clock and timezone
S_PART=0        # partitioning
S_MKFS=0        # formatting
S_MKFSAUTO=0    # auto fs part/formatting TODO: kill this
S_CONFIG=0      # configuration editing
S_GRUB=0        # TODO: kill this - if using grub
S_BOOT=""       # bootloader installed (set to loader name instead of 1)
S_FDE=0         # Full disk encryption, need key in /boot

# main menu selection tracker
CURRENT_SELECTION=""

# getuuid()
# converts /dev/[hs]d?[0-9] devices to UUIDs
#
# parameters: device file
# outputs:    UUID on success
#             nothing on failure
# returns:    nothing
getuuid()
{
    if [ "${1%%/[hs]d?[0-9]}" != "${1}" ]; then
        echo "$(blkid -s UUID -o value ${1})"
    fi
}

# getkernelversion()
# outputs the kernel version
#
# parameters: none
# outputs:    kernel version on success
#             nothing on failure
# returns:    0 on success
#             1 on failure
getkernelversion()
{
    local kernver=$(ls ${DESTDIR}/boot/kernel-genkernel-* |sed -e "s|kernel-genkernel||g" -e "s|${DESTDIR}/boot/||") \
        || return 1
    echo "${kernver}"
}

get_grub_map() {
    [ -e /tmp/dev.map ] && rm /tmp/dev.map
    show_dialog --infobox "Generating GRUB device map...\nThis could take a while.\n\n Please be patient." 0 0
    ${DESTDIR}/sbin/grub --no-floppy --device-map /tmp/dev.map >/tmp/grub.log 2>&1 <<EOF
quit
EOF
}

mapdev() {
    partition_flag=0
    device_found=0
    devs=$(cat /tmp/dev.map | grep -v fd | sed 's/ *\t/ /' | sed ':a;$!N;$!ba;s/\n/ /g')
    linuxdevice=$(echo $1 | cut -b1-8)
    if [ "$(echo $1 | egrep '[0-9]$')" ]; then
        # /dev/hdXY
        pnum=$(echo $1 | cut -b9-)
        pnum=$((${pnum}-1))
        partition_flag=1
    fi
    for  dev in ${devs}
    do
        if [ "(" = $(echo ${dev} | cut -b1) ]; then
        grubdevice="${dev}"
        else
        if [ "${dev}" = "${linuxdevice}" ]; then
            device_found=1
            break
        fi
       fi
    done
    if [ "${device_found}" = "1" ]; then
        if [ "${partition_flag}" = "0" ]; then
            echo "${grubdevice}"
        else
            grubdevice_stringlen=${#grubdevice}
            grubdevice_stringlen=$((${grubdevice_stringlen} - 1))
            grubdevice=$(echo ${grubdevice} | cut -b1-${grubdevice_stringlen})
            echo "${grubdevice},${pnum})"
        fi
    else
        echo "_DEVICE NOT FOUND"
    fi
}

# douefigrub()
# writes kernel to UEFI as new boot option
# parameters:
#     kernelpath: path to kernel, relative to partition root
#     initrdpath: path to initrd
#     bootparams: other boot params for kernel
# returns: 1 on failure
douefigrub() {
    # check if grub2 is installed
    grub2-mkimage -? 2>/dev/null 1>&2
    if [ $? -ne 0 ]; then
        show_dialog --msgbox "Error: Couldn't find grub2-mkimage.  Is GRUB-2 installed?" 0 0
        return 1
    fi
    local kernelpath="${1}"
    local initrdpath="${2}"
    local bootparams="${3}"
    # uefipart: uefi partition, ex. /dev/sda1
    show_dialog --menu "Select the partition to use as UEFI boot partition" 21 50 13 NONE - ${PARTS} 2>"${ANSWER}" || return 1
    local uefipart=$(get_answer)
    PARTS="$(echo ${PARTS} | sed -e "s#${uefipart}\ _##g")"
    [ "${uefipart}" = "NONE" ] && return 1
    # grubpart: grub partition, ex. (hd0,2)
    show_dialog --inputbox "Verify your GRUB device path" 8 65 "(hd0,2)" 2>"${ANSWER}" || return 1
    local grubpart=$(get_answer)
    # uefimount: uefi partition mount point, ex. /boot
    local uefimount="$(mount | grep "^${uefipart} " | cut -d' ' -f 3)"
    # mount if not mounted
    if [ "${uefimount}" = "" ]; then
        mkdir -p /tmp/efibootpart || return 1
        mount "${uefipart}" /tmp/efibootpart || return 1
        uefimount=/tmp/efibootpart
    fi
    # safety check for /EFI/BOOT/BOOTX64.EFI (case insensitive for fat)
    local findefi="$(find "${uefimount}" -iwholename "${uefimount}/efi/boot/bootx64.efi")"
    if [ "${findefi}" != "" ]; then
        show_dialog --msgbox "Error: ${findefi} exists, refusing to overwrite!" 0 0
        return 1
    fi
    # safety check for /boot/grub2 (case insensitive for fat)
    local findgrub2="$(find "${uefimount}" -iwholename "${uefimount}/boot/grub2")"
    if [ "${findgrub2}" != "" ]; then
        show_dialog --msgbox "Error: ${findgrub2} exists, refusing to overwrite!" 0 0
        return 1
    fi
    # create grub image
    mkdir -p "${uefimount}/EFI/BOOT" || return 1
    grub2-mkimage -p /boot/grub2 -o "${uefimount}/EFI/BOOT/BOOTX64.EFI" -O x86_64-efi part_msdos part_gpt fat normal \
        || return 1
    # copy grub modules
    mkdir -p "${uefimount}/boot/grub2" || return 1
    cp -ar /usr/lib/grub/x86_64-efi "${uefimount}/boot/grub2/" \
        || return 1
    # create a crude grug.cfg
    mkdir -p "${uefimount}/boot/grub2" || return 1
    cat >> "${uefimount}/boot/grub2/grub.cfg" <<EOF
timeout=5
menuentry 'Pentoo' {
    insmod efi_gop
    insmod efi_uga
    insmod part_msdos
    insmod part_gpt
    root=${grubpart}
    linux ${kernelpath} ${bootparams}
    initrd ${initrdpath}
}
EOF
    show_dialog --msgbox "UEFI boot image successfully installed. You can now review the GRUB-2 config file." 0 0
    [ "${EDITOR}" ] || seteditor
    ${EDITOR} "${uefimount}/boot/grub2/grub.cfg"
    show_dialog --msgbox "Success: UEFI booting by GRUB-2 installed!" 0 0
}

# douefi()
# writes kernel to UEFI as new boot option
# parameters:
#     kernelpath: path to kernel, relative to partition root
#     initrdpath: path to initrd
#     bootparams: other boot params for kernel
# returns: 1 on failure
#
douefi() {
    modprobe efivars
    # check if booted through UEFI
    efibootmgr -v 2>/dev/null 1>&2
    if [ $? -ne 0 ]; then
        show_dialog --msgbox "Error: Couldn't read from UEFI. Did you boot through UEFI?" 0 0
        return 1
    fi
    # kernel path with \\ instead of /
    local kernelpath=${1//\//\\\\}
    # initrd path with \ instead of /
    local initrdpath=${2//\//\\}
    local bootparams="${3}"
    # kernelpart: kernel partition, ex. /dev/sda2
    show_dialog --menu "Select the partition with the kernel (/boot)" 21 50 13 NONE - ${PARTS} 2>"${ANSWER}" || return 1
    local kernelpart=$(get_answer)
    PARTS="$(echo ${PARTS} | sed -e "s#${kernelpart}\ _##g")"
    [ "${kernelpart}" = "NONE" ] && return 1
    # kernelpart as disk and trailing part-number
    local kernelpartnu=$(expr match "${kernelpart}" '.*\([1-9][0-9]*\)')
    local kernelpartdisk=${kernelpart:0: -${#kernelpartnu}}
    # write to UEFI
    echo "${bootparams} initrd=${initrdpath}" | \
        iconv -f ascii -t ucs2 | \
        efibootmgr --create --gpt \
            --disk "${kernelpartdisk}" --part "${kernelpartnu}" \
            --label "Pentoo" \
            --loader "${kernelpath}" \
            --append-binary-args -
    if [ $? -ne 0 ]; then
        show_dialog --msgbox "Error: Couldn't write to UEFI!" 0 0
        return 1
    fi
    show_dialog --msgbox "Success: Direct UEFI booting installed!" 0 0
}

# dobootloader()
# installs boot loader
# parameters:
#     bootmode:
#         - uefigrub: installs GRUB2 UEFI-image plus menu
#         - uefi: boot kernel direclty by UEFI
# returns: 1 on failure
#
dobootloader() {
    local bootmode="${1}"
    local _kernver=$(getkernelversion)
    local kernelpath="/boot/kernel-genkernel${_kernver}"
    local initrdpath="/boot/initramfs-genkernel${_kernver}"
    local bootparams="root=/dev/ram0 real_root=${PART_ROOT}"
    # select UEFI boot partition
    PARTS=$(findpartitions _)
    # compose boot parameters
    # parse kernel cmdline (only video mode for now)
    for _var in $(cat /proc/cmdline); do
        case ${_var} in
            video=*)
                eval $(echo ${_var}) ;;
        esac
    done
    bootparams+=" video=${video} console=tty0 usbcore.autosuspend=1 net.ifnames=0 ro"
    case "${bootmode}" in
        uefigrub)
            douefigrub "${kernelpath}" "${initrdpath}" "${bootparams}" \
                || return 1
            ;;
        uefi)
            douefi "${kernelpath}" "${initrdpath}" "${bootparams}" \
            || return 1
            ;;
    esac
}

# dogrub()
# installs grub
# params: none
# returns: 1 on failure
dogrub() {
    get_grub_map
    local grubmenu="${DESTDIR}/boot/grub/grub.conf"
    rm ${DESTDIR}/boot/grub/menu.lst
    ln -s ./grub.conf ${DESTDIR}/boot/grub/menu.lst
    if [ ! -f ${grubmenu} ]; then
        show_dialog --msgbox "Error: Couldn't find ${grubmenu.}  Is GRUB installed?" 0 0
        return 1
    fi
    # try to auto-configure GRUB...
    if [ "${PART_ROOT}" != "" -a "${S_GRUB}" != "1" ]; then
        grubdev=$(mapdev ${PART_ROOT})
        local _rootpart="${PART_ROOT}"
        # look for a separately-mounted /boot partition
        bootdev=$(mount | grep ${DESTDIR}/boot | cut -d' ' -f 1)
        if [ "${grubdev}" != "" -o "${bootdev}" != "" ]; then
            subdir=
            if [ "${bootdev}" != "" ]; then
                grubdev=$(mapdev ${bootdev})
            else
                subdir="/boot"
            fi
            # keep the file from being completely bogus
            if [ "${grubdev}" = "_DEVICE NOT FOUND" ]; then
                show_dialog --msgbox "Your root boot device could not be autodetected by setup.  Ensure you adjust the 'root (hd0,0)' line in your GRUB config accordingly." 0 0
                grubdev="(hd0,0)"
            fi
            # remove default entries
            sed -i 's/^#splashimage/splashimage/' ${grubmenu}
            sed -i '/^#/d' ${grubmenu}
	        # parse kernel cmdline (only video mode for now)
	        for _var in $(cat /proc/cmdline)
	        do
			    case ${_var} in
				    video=*)
				    eval $(echo ${_var})
				    ;;
			    esac
		    done
	        # get kernel version
	        local _kernver=$(getkernelversion)
            if [ ${S_FDE} = 1 ]; then
                cat >>${grubmenu} <<EOF

# (0) Pentoo
title  Pentoo
root   ${grubdev}
kernel ${subdir}/kernel-genkernel${_kernver} root=/dev/ram0 real_root=/dev/mapper/root dogpg crypt_root=${_rootpart} root_key=/key.gpg root_keydev=${bootdev} ${_cmdline} video=${video} console=tty1 net.ifnames=0 ro
initrd ${subdir}/initramfs-genkernel${_kernver}

# (2) Windows
#title Windows
#rootnoverify (hd0,0)
#makeactive
#chainloader +1
EOF
            else
                cat >>${grubmenu} <<EOF

# (0) Pentoo
title  Pentoo
root   ${grubdev}
kernel ${subdir}/kernel-genkernel${_kernver} root=/dev/ram0 real_root=${_rootpart} ${_cmdline} video=${video} console=tty1 net.ifnames=0 ro
initrd ${subdir}/initramfs-genkernel${_kernver}

# (2) Windows
#title Windows
#rootnoverify (hd0,0)
#makeactive
#chainloader +1
EOF
            fi
        fi
    fi

    show_dialog --msgbox "Before installing GRUB, you must review the configuration file.  You will now be put into the editor.  After you save your changes and exit the editor, you can install GRUB." 0 0
    [ "${EDITOR}" ] || seteditor
    ${EDITOR} ${grubmenu}

    DEVS=$(partition_finddisks _)
    DEVS="${DEVS} $(findpartitions _)"
    if [ "${DEVS}" = "" ]; then
        show_dialog --msgbox "No hard drives were found" 0 0
        return 1
    fi
    show_dialog --menu "Select the boot device where the GRUB bootloader will be installed (usually the MBR and not a partition)." 14 55 7 ${DEVS} 2>"${ANSWER}" || return 1
    ROOTDEV=$(get_answer)
    show_dialog --infobox "Installing the GRUB bootloader..." 0 0
    if [ -d "${DESTDIR}"/usr/lib/grub/i386-pc ]; then
        cp -a "${DESTDIR}"/usr/lib/grub/i386-pc/* "${DESTDIR}"/boot/grub/
    fi
    sync
    # freeze xfs filesystems to enable grub installation on xfs filesystems
    if [ -x /usr/sbin/xfs_freeze ]; then
        mount | grep ${DESTDIR}/boot | grep -q xfs && /usr/sbin/xfs_freeze -f ${DESTDIR}/boot > /dev/null 2>&1
        mount | grep ${DESTDIR} | grep -q xfs && /usr/sbin/xfs_freeze -f ${DESTDIR}/ > /dev/null 2>&1
    fi
    # look for a separately-mounted /boot partition
    bootpart=$(mount | grep ${DESTDIR}/boot | cut -d' ' -f 1)
    if [ "${bootpart}" = "" ]; then
        if [ "${PART_ROOT}" = "" ]; then
            show_dialog --inputbox "Enter the full path to your root device" 8 65 "/dev/sda3" 2>"${ANSWER}" || return 1
            bootpart=$(get_answer)
        else
            bootpart=${PART_ROOT}
        fi
    fi
    show_dialog --defaultno --yesno "Do you have your system installed on software raid?\nAnswer 'YES' to install grub to another hard disk." 0 0
    if [ $? -eq 0 ]; then
        show_dialog --menu "Please select the boot partition device, this cannot be autodetected!\nPlease redo grub installation for all partitions you need it!" 14 55 7 ${DEVS} 2>"${ANSWER}" || return 1
        bootpart=$(get_answer)
    fi
    bootpart=$(mapdev ${bootpart})
    bootdev=$(mapdev ${ROOTDEV})
    if [ "${bootpart}" = "" ]; then
        show_dialog --msgbox "Error: Missing/Invalid root device: ${bootpart}" 0 0
        return 1
    fi
    if [ "${bootpart}" = "_DEVICE NOT FOUND" -o "${bootdev}" = "_DEVICE NOT FOUND" ]; then
        show_dialog --msgbox "GRUB root and setup devices could not be auto-located.  You will need to manually run the GRUB shell to install a bootloader." 0 0
        return 1
    fi
    /sbin/grub-install --no-floppy --recheck --grub-shell=${DESTDIR}/sbin/grub --root-directory=${DESTDIR} ${ROOTDEV} >/tmp/grub.log 2>&1
    cat /tmp/grub.log >"${LOG}"
    # unfreeze xfs filesystems
    if [ -x /usr/sbin/xfs_freeze ]; then
        mount | grep ${DESTDIR}/boot | grep -q xfs && /usr/sbin/xfs_freeze -u ${DESTDIR}/boot > /dev/null 2>&1
        mount | grep ${DESTDIR}/boot | grep -q xfs && /usr/sbin/xfs_freeze -u ${DESTDIR}/ > /dev/null 2>&1
    fi

    if grep "Error [0-9]*: " /tmp/grub.log >/dev/null; then
        show_dialog --msgbox "Error installing GRUB. (see ${LOG} for output)" 0 0
        return 1
    fi
    show_dialog --msgbox "GRUB was successfully installed." 0 0
    S_GRUB=1
}

install_bootloader()
{
    show_dialog --colors --menu "Which bootloader would you like to use?  Grub is the Pentoo default.\n\n" \
        12 75 4 \
        "GRUB" "Use the GRUB bootloader (default)" \
        "UEFI-GRUB" "Use GRUB2 and UEFI (unsupported)" \
        "UEFI" "Boot kernel directly by UEFI (unsupported)" \
        "None" "\Zb\Z1Warning\Z0\ZB: you must install your own bootloader!" 2>"${ANSWER}"
    case $(get_answer) in
        "GRUB") dogrub ;;
        "UEFI-GRUB") dobootloader 'uefigrub' ;;
        "UEFI") dobootloader 'uefi' ;;
    esac
}
